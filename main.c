#define M_STACK 100
#define M_STR 100
#include <stdio.h>
#include <string.h>

/* Реализация стека. Мне кажется, есть смысл хранить элементы обоих
 * стеков как строки */

typedef struct stack{
    int top;
    char element[M_STACK][M_STR];
}stack;

int main() {
    char str[M_STR] = {0}; // Для считывания операндов из более чем одного символа
    char expression[] = {0};  // тут будет наше математическое выражение
    gets(expression);

    /* Тут будет какой-нибудь код, который вычленяет само выражение */
    stack stack_num; // Создаем стеки для чисел и операций
    stack stack_op;
    stack_op.top = 0;
    stack_num.top = 0;

    /* Начинаем проход по выражению, разбиваем составляющие на два стека */
    for(int i = 0; expression[i]; ++i){
       switch (expression[i]) {
           case '+':
           case '-':
           case '*':
           case '/':
           case '(':
               strcpy(stack_op.element[stack_op.top],expression[i]);
               stack_op.top++; //Добавляем операцию в стек
               if (strlen(str) > 0){
                   strcpy(stack_num.element[stack_num.top], str);
                   stack_num.top++; // Проверяем, был ли до этого операнд, если да, записываем
                   /* Тут должна занулиться str */
               }
               break;
           case ')':
               /* Вот тут мы выполняем проход по обоим стекам
                * выполняем операции над элементами стека операндо пока не встретим '(' */
           default:
               str[strlen(str)-1] = expression[i]; // Сохраняем кусок операнда
               break;
       }
    }
    return 0;
}

/*---------------------
 * Я не выкупил саму суть такой идеи. Т.е. у нас перед самим выражением на вход еще
 * и описание переменных подается? В любом случае, не вижу смысла сейчас сильно париться
 * насчет этого, сейчас я попытаюсь заложить основу проекта для работы хотя бы с обычными
 * числами, потом уже будем докручивать */

/* Короче, чего я подумал. Итоговое выражение содержит переменные,
 * которые тоже могут задаваться выражениями. Получается, нам нужна
 * какая-то отдельная функция, принимающая на вход строку с выражением
 * и считающая его. Если она встречает переменную, заданную выражнием,
 * мы еще раз рекурсивно вызываем эту самую функцию. Еще надо как-то
 * проверить, является ли переменная числом или задана выражением...
 *
 * Пример от Лупановой:
 *
 * exp(-j*PI*alpha*len/v0)           <- основное выражение
 * alpha = sqrt(PI*len/(s1+s2))      <- alpha задано выражением
 * s1 = cos(real(S11)*real(S22))
 * s2 = (sin(imag(S11*S22)))^2
 * len = 191.76                      <- len задано числом
 * v0 = 299.799
 * S11 = -0.01-0.92j
 * S22 = 0.0001+0.997j
 *
 * И еще список выражений и констант:
 *
 * Operations list:
 * +
 * -
 * /
 * *
 * ^
 * sqrt
 * cos
 * sin
 * tg
 * log
 * ln
 * pow
 * abs
 * exp
 * real
 * imag
 * mag
 * phase
 *
 * Constants:
 * PI
 * e
 * j
 */

